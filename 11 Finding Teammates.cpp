// 这题可用动态规划
#include <iostream>
using namespace std;
typedef long long ll;

static ll F[26];

// 计算C(n,k)
ll C(ll n, ll k)
{
    ll a = 1, b = 1;
    if (k > n - k)
        k = n - k;  // C(n,k)=C(n,n-k)
    for (ll i = 0; i < k; i++)
    {
        a *= n - i;
        b *= k - i;
    }
    return a / b;
}

int main()
{
    int n;
    // 如果我们知道了F[1..n]，如何求F[n+1]?
    // 我们把n+1序列中最大的数max拿出来单独放置，那么它一定在某个组的最后面，
    // 设它所在的组是第x组（下标从1开始），则它前面有（3x-1）个数，后面有(n-3x+1)个数
    // 而前面的数本身可以有C(n, 3x-1)种取法（F本身只反映一个相对的关系，
    // 你用1234得到的F[4]的3种情况为2341、1342、1243,后面用到F[4]时是从n中抽出4个数
    // 按照3种情况排序获得的结果。而在取了数之后，后面的数就确定是剩下的那些了，前后的排序
    // 情况相互独立，故F[n+1]=sum(F[3x-1]*F[n-3x+1]*C(n, 3x-1))。
    // 但是，如果max在最后一组，当n%3==1时，它前面不是(3x-1)个数（因为它是最后一组的第二个数），
    // 而是n个数，因此要加上F[n]（原先计算最后一组时因为x=(n-1)/3+1,F[3x-1]=F[n+1]=0而将
    // 这一组的情况计为0了）
    F[0] = F[1] = 1;
    while (cin >> n)
    {
        for (int i = 1; i < n; i++)
        {
            if (F[i+1] != 0)
                continue;
            int x = i / 3 + 1;
            for (int j = 1; j <= x; j++)
                F[i+1] += F[3*j-1] * F[i-3*j+1] * C(i,3*j-1);
            if (i % 3 == 1)
                F[i+1] += F[i];
        }
        cout << F[n] << endl;
    }
}
/*
1
1
1
3
9
19
99
477
1513
11259
74601
315523
3052323
25740261
136085041
1620265923
16591655817
105261234643
1488257158851
17929265150637
132705221399353
2172534146099019
30098784753112329
254604707462013571
4736552519729393091
*/